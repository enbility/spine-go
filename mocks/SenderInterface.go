// Code generated by mockery v2.42.1. DO NOT EDIT.

package mocks

import (
	model "github.com/enbility/spine-go/model"
	mock "github.com/stretchr/testify/mock"
)

// SenderInterface is an autogenerated mock type for the SenderInterface type
type SenderInterface struct {
	mock.Mock
}

type SenderInterface_Expecter struct {
	mock *mock.Mock
}

func (_m *SenderInterface) EXPECT() *SenderInterface_Expecter {
	return &SenderInterface_Expecter{mock: &_m.Mock}
}

// Bind provides a mock function with given fields: senderAddress, destinationAddress, serverFeatureType
func (_m *SenderInterface) Bind(senderAddress *model.FeatureAddressType, destinationAddress *model.FeatureAddressType, serverFeatureType model.FeatureTypeType) (*model.MsgCounterType, error) {
	ret := _m.Called(senderAddress, destinationAddress, serverFeatureType)

	if len(ret) == 0 {
		panic("no return value specified for Bind")
	}

	var r0 *model.MsgCounterType
	var r1 error
	if rf, ok := ret.Get(0).(func(*model.FeatureAddressType, *model.FeatureAddressType, model.FeatureTypeType) (*model.MsgCounterType, error)); ok {
		return rf(senderAddress, destinationAddress, serverFeatureType)
	}
	if rf, ok := ret.Get(0).(func(*model.FeatureAddressType, *model.FeatureAddressType, model.FeatureTypeType) *model.MsgCounterType); ok {
		r0 = rf(senderAddress, destinationAddress, serverFeatureType)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.MsgCounterType)
		}
	}

	if rf, ok := ret.Get(1).(func(*model.FeatureAddressType, *model.FeatureAddressType, model.FeatureTypeType) error); ok {
		r1 = rf(senderAddress, destinationAddress, serverFeatureType)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SenderInterface_Bind_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Bind'
type SenderInterface_Bind_Call struct {
	*mock.Call
}

// Bind is a helper method to define mock.On call
//   - senderAddress *model.FeatureAddressType
//   - destinationAddress *model.FeatureAddressType
//   - serverFeatureType model.FeatureTypeType
func (_e *SenderInterface_Expecter) Bind(senderAddress interface{}, destinationAddress interface{}, serverFeatureType interface{}) *SenderInterface_Bind_Call {
	return &SenderInterface_Bind_Call{Call: _e.mock.On("Bind", senderAddress, destinationAddress, serverFeatureType)}
}

func (_c *SenderInterface_Bind_Call) Run(run func(senderAddress *model.FeatureAddressType, destinationAddress *model.FeatureAddressType, serverFeatureType model.FeatureTypeType)) *SenderInterface_Bind_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*model.FeatureAddressType), args[1].(*model.FeatureAddressType), args[2].(model.FeatureTypeType))
	})
	return _c
}

func (_c *SenderInterface_Bind_Call) Return(_a0 *model.MsgCounterType, _a1 error) *SenderInterface_Bind_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *SenderInterface_Bind_Call) RunAndReturn(run func(*model.FeatureAddressType, *model.FeatureAddressType, model.FeatureTypeType) (*model.MsgCounterType, error)) *SenderInterface_Bind_Call {
	_c.Call.Return(run)
	return _c
}

// DatagramForMsgCounter provides a mock function with given fields: msgCounter
func (_m *SenderInterface) DatagramForMsgCounter(msgCounter model.MsgCounterType) (model.DatagramType, error) {
	ret := _m.Called(msgCounter)

	if len(ret) == 0 {
		panic("no return value specified for DatagramForMsgCounter")
	}

	var r0 model.DatagramType
	var r1 error
	if rf, ok := ret.Get(0).(func(model.MsgCounterType) (model.DatagramType, error)); ok {
		return rf(msgCounter)
	}
	if rf, ok := ret.Get(0).(func(model.MsgCounterType) model.DatagramType); ok {
		r0 = rf(msgCounter)
	} else {
		r0 = ret.Get(0).(model.DatagramType)
	}

	if rf, ok := ret.Get(1).(func(model.MsgCounterType) error); ok {
		r1 = rf(msgCounter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SenderInterface_DatagramForMsgCounter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DatagramForMsgCounter'
type SenderInterface_DatagramForMsgCounter_Call struct {
	*mock.Call
}

// DatagramForMsgCounter is a helper method to define mock.On call
//   - msgCounter model.MsgCounterType
func (_e *SenderInterface_Expecter) DatagramForMsgCounter(msgCounter interface{}) *SenderInterface_DatagramForMsgCounter_Call {
	return &SenderInterface_DatagramForMsgCounter_Call{Call: _e.mock.On("DatagramForMsgCounter", msgCounter)}
}

func (_c *SenderInterface_DatagramForMsgCounter_Call) Run(run func(msgCounter model.MsgCounterType)) *SenderInterface_DatagramForMsgCounter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(model.MsgCounterType))
	})
	return _c
}

func (_c *SenderInterface_DatagramForMsgCounter_Call) Return(_a0 model.DatagramType, _a1 error) *SenderInterface_DatagramForMsgCounter_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *SenderInterface_DatagramForMsgCounter_Call) RunAndReturn(run func(model.MsgCounterType) (model.DatagramType, error)) *SenderInterface_DatagramForMsgCounter_Call {
	_c.Call.Return(run)
	return _c
}

// Notify provides a mock function with given fields: senderAddress, destinationAddress, cmd
func (_m *SenderInterface) Notify(senderAddress *model.FeatureAddressType, destinationAddress *model.FeatureAddressType, cmd model.CmdType) (*model.MsgCounterType, error) {
	ret := _m.Called(senderAddress, destinationAddress, cmd)

	if len(ret) == 0 {
		panic("no return value specified for Notify")
	}

	var r0 *model.MsgCounterType
	var r1 error
	if rf, ok := ret.Get(0).(func(*model.FeatureAddressType, *model.FeatureAddressType, model.CmdType) (*model.MsgCounterType, error)); ok {
		return rf(senderAddress, destinationAddress, cmd)
	}
	if rf, ok := ret.Get(0).(func(*model.FeatureAddressType, *model.FeatureAddressType, model.CmdType) *model.MsgCounterType); ok {
		r0 = rf(senderAddress, destinationAddress, cmd)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.MsgCounterType)
		}
	}

	if rf, ok := ret.Get(1).(func(*model.FeatureAddressType, *model.FeatureAddressType, model.CmdType) error); ok {
		r1 = rf(senderAddress, destinationAddress, cmd)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SenderInterface_Notify_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Notify'
type SenderInterface_Notify_Call struct {
	*mock.Call
}

// Notify is a helper method to define mock.On call
//   - senderAddress *model.FeatureAddressType
//   - destinationAddress *model.FeatureAddressType
//   - cmd model.CmdType
func (_e *SenderInterface_Expecter) Notify(senderAddress interface{}, destinationAddress interface{}, cmd interface{}) *SenderInterface_Notify_Call {
	return &SenderInterface_Notify_Call{Call: _e.mock.On("Notify", senderAddress, destinationAddress, cmd)}
}

func (_c *SenderInterface_Notify_Call) Run(run func(senderAddress *model.FeatureAddressType, destinationAddress *model.FeatureAddressType, cmd model.CmdType)) *SenderInterface_Notify_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*model.FeatureAddressType), args[1].(*model.FeatureAddressType), args[2].(model.CmdType))
	})
	return _c
}

func (_c *SenderInterface_Notify_Call) Return(_a0 *model.MsgCounterType, _a1 error) *SenderInterface_Notify_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *SenderInterface_Notify_Call) RunAndReturn(run func(*model.FeatureAddressType, *model.FeatureAddressType, model.CmdType) (*model.MsgCounterType, error)) *SenderInterface_Notify_Call {
	_c.Call.Return(run)
	return _c
}

// Reply provides a mock function with given fields: requestHeader, senderAddress, cmd
func (_m *SenderInterface) Reply(requestHeader *model.HeaderType, senderAddress *model.FeatureAddressType, cmd model.CmdType) error {
	ret := _m.Called(requestHeader, senderAddress, cmd)

	if len(ret) == 0 {
		panic("no return value specified for Reply")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*model.HeaderType, *model.FeatureAddressType, model.CmdType) error); ok {
		r0 = rf(requestHeader, senderAddress, cmd)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SenderInterface_Reply_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Reply'
type SenderInterface_Reply_Call struct {
	*mock.Call
}

// Reply is a helper method to define mock.On call
//   - requestHeader *model.HeaderType
//   - senderAddress *model.FeatureAddressType
//   - cmd model.CmdType
func (_e *SenderInterface_Expecter) Reply(requestHeader interface{}, senderAddress interface{}, cmd interface{}) *SenderInterface_Reply_Call {
	return &SenderInterface_Reply_Call{Call: _e.mock.On("Reply", requestHeader, senderAddress, cmd)}
}

func (_c *SenderInterface_Reply_Call) Run(run func(requestHeader *model.HeaderType, senderAddress *model.FeatureAddressType, cmd model.CmdType)) *SenderInterface_Reply_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*model.HeaderType), args[1].(*model.FeatureAddressType), args[2].(model.CmdType))
	})
	return _c
}

func (_c *SenderInterface_Reply_Call) Return(_a0 error) *SenderInterface_Reply_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *SenderInterface_Reply_Call) RunAndReturn(run func(*model.HeaderType, *model.FeatureAddressType, model.CmdType) error) *SenderInterface_Reply_Call {
	_c.Call.Return(run)
	return _c
}

// Request provides a mock function with given fields: cmdClassifier, senderAddress, destinationAddress, ackRequest, cmd
func (_m *SenderInterface) Request(cmdClassifier model.CmdClassifierType, senderAddress *model.FeatureAddressType, destinationAddress *model.FeatureAddressType, ackRequest bool, cmd []model.CmdType) (*model.MsgCounterType, error) {
	ret := _m.Called(cmdClassifier, senderAddress, destinationAddress, ackRequest, cmd)

	if len(ret) == 0 {
		panic("no return value specified for Request")
	}

	var r0 *model.MsgCounterType
	var r1 error
	if rf, ok := ret.Get(0).(func(model.CmdClassifierType, *model.FeatureAddressType, *model.FeatureAddressType, bool, []model.CmdType) (*model.MsgCounterType, error)); ok {
		return rf(cmdClassifier, senderAddress, destinationAddress, ackRequest, cmd)
	}
	if rf, ok := ret.Get(0).(func(model.CmdClassifierType, *model.FeatureAddressType, *model.FeatureAddressType, bool, []model.CmdType) *model.MsgCounterType); ok {
		r0 = rf(cmdClassifier, senderAddress, destinationAddress, ackRequest, cmd)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.MsgCounterType)
		}
	}

	if rf, ok := ret.Get(1).(func(model.CmdClassifierType, *model.FeatureAddressType, *model.FeatureAddressType, bool, []model.CmdType) error); ok {
		r1 = rf(cmdClassifier, senderAddress, destinationAddress, ackRequest, cmd)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SenderInterface_Request_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Request'
type SenderInterface_Request_Call struct {
	*mock.Call
}

// Request is a helper method to define mock.On call
//   - cmdClassifier model.CmdClassifierType
//   - senderAddress *model.FeatureAddressType
//   - destinationAddress *model.FeatureAddressType
//   - ackRequest bool
//   - cmd []model.CmdType
func (_e *SenderInterface_Expecter) Request(cmdClassifier interface{}, senderAddress interface{}, destinationAddress interface{}, ackRequest interface{}, cmd interface{}) *SenderInterface_Request_Call {
	return &SenderInterface_Request_Call{Call: _e.mock.On("Request", cmdClassifier, senderAddress, destinationAddress, ackRequest, cmd)}
}

func (_c *SenderInterface_Request_Call) Run(run func(cmdClassifier model.CmdClassifierType, senderAddress *model.FeatureAddressType, destinationAddress *model.FeatureAddressType, ackRequest bool, cmd []model.CmdType)) *SenderInterface_Request_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(model.CmdClassifierType), args[1].(*model.FeatureAddressType), args[2].(*model.FeatureAddressType), args[3].(bool), args[4].([]model.CmdType))
	})
	return _c
}

func (_c *SenderInterface_Request_Call) Return(_a0 *model.MsgCounterType, _a1 error) *SenderInterface_Request_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *SenderInterface_Request_Call) RunAndReturn(run func(model.CmdClassifierType, *model.FeatureAddressType, *model.FeatureAddressType, bool, []model.CmdType) (*model.MsgCounterType, error)) *SenderInterface_Request_Call {
	_c.Call.Return(run)
	return _c
}

// ResultError provides a mock function with given fields: requestHeader, senderAddress, err
func (_m *SenderInterface) ResultError(requestHeader *model.HeaderType, senderAddress *model.FeatureAddressType, err *model.ErrorType) error {
	ret := _m.Called(requestHeader, senderAddress, err)

	if len(ret) == 0 {
		panic("no return value specified for ResultError")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*model.HeaderType, *model.FeatureAddressType, *model.ErrorType) error); ok {
		r0 = rf(requestHeader, senderAddress, err)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SenderInterface_ResultError_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResultError'
type SenderInterface_ResultError_Call struct {
	*mock.Call
}

// ResultError is a helper method to define mock.On call
//   - requestHeader *model.HeaderType
//   - senderAddress *model.FeatureAddressType
//   - err *model.ErrorType
func (_e *SenderInterface_Expecter) ResultError(requestHeader interface{}, senderAddress interface{}, err interface{}) *SenderInterface_ResultError_Call {
	return &SenderInterface_ResultError_Call{Call: _e.mock.On("ResultError", requestHeader, senderAddress, err)}
}

func (_c *SenderInterface_ResultError_Call) Run(run func(requestHeader *model.HeaderType, senderAddress *model.FeatureAddressType, err *model.ErrorType)) *SenderInterface_ResultError_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*model.HeaderType), args[1].(*model.FeatureAddressType), args[2].(*model.ErrorType))
	})
	return _c
}

func (_c *SenderInterface_ResultError_Call) Return(_a0 error) *SenderInterface_ResultError_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *SenderInterface_ResultError_Call) RunAndReturn(run func(*model.HeaderType, *model.FeatureAddressType, *model.ErrorType) error) *SenderInterface_ResultError_Call {
	_c.Call.Return(run)
	return _c
}

// ResultSuccess provides a mock function with given fields: requestHeader, senderAddress
func (_m *SenderInterface) ResultSuccess(requestHeader *model.HeaderType, senderAddress *model.FeatureAddressType) error {
	ret := _m.Called(requestHeader, senderAddress)

	if len(ret) == 0 {
		panic("no return value specified for ResultSuccess")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*model.HeaderType, *model.FeatureAddressType) error); ok {
		r0 = rf(requestHeader, senderAddress)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SenderInterface_ResultSuccess_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResultSuccess'
type SenderInterface_ResultSuccess_Call struct {
	*mock.Call
}

// ResultSuccess is a helper method to define mock.On call
//   - requestHeader *model.HeaderType
//   - senderAddress *model.FeatureAddressType
func (_e *SenderInterface_Expecter) ResultSuccess(requestHeader interface{}, senderAddress interface{}) *SenderInterface_ResultSuccess_Call {
	return &SenderInterface_ResultSuccess_Call{Call: _e.mock.On("ResultSuccess", requestHeader, senderAddress)}
}

func (_c *SenderInterface_ResultSuccess_Call) Run(run func(requestHeader *model.HeaderType, senderAddress *model.FeatureAddressType)) *SenderInterface_ResultSuccess_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*model.HeaderType), args[1].(*model.FeatureAddressType))
	})
	return _c
}

func (_c *SenderInterface_ResultSuccess_Call) Return(_a0 error) *SenderInterface_ResultSuccess_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *SenderInterface_ResultSuccess_Call) RunAndReturn(run func(*model.HeaderType, *model.FeatureAddressType) error) *SenderInterface_ResultSuccess_Call {
	_c.Call.Return(run)
	return _c
}

// Subscribe provides a mock function with given fields: senderAddress, destinationAddress, serverFeatureType
func (_m *SenderInterface) Subscribe(senderAddress *model.FeatureAddressType, destinationAddress *model.FeatureAddressType, serverFeatureType model.FeatureTypeType) (*model.MsgCounterType, error) {
	ret := _m.Called(senderAddress, destinationAddress, serverFeatureType)

	if len(ret) == 0 {
		panic("no return value specified for Subscribe")
	}

	var r0 *model.MsgCounterType
	var r1 error
	if rf, ok := ret.Get(0).(func(*model.FeatureAddressType, *model.FeatureAddressType, model.FeatureTypeType) (*model.MsgCounterType, error)); ok {
		return rf(senderAddress, destinationAddress, serverFeatureType)
	}
	if rf, ok := ret.Get(0).(func(*model.FeatureAddressType, *model.FeatureAddressType, model.FeatureTypeType) *model.MsgCounterType); ok {
		r0 = rf(senderAddress, destinationAddress, serverFeatureType)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.MsgCounterType)
		}
	}

	if rf, ok := ret.Get(1).(func(*model.FeatureAddressType, *model.FeatureAddressType, model.FeatureTypeType) error); ok {
		r1 = rf(senderAddress, destinationAddress, serverFeatureType)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SenderInterface_Subscribe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Subscribe'
type SenderInterface_Subscribe_Call struct {
	*mock.Call
}

// Subscribe is a helper method to define mock.On call
//   - senderAddress *model.FeatureAddressType
//   - destinationAddress *model.FeatureAddressType
//   - serverFeatureType model.FeatureTypeType
func (_e *SenderInterface_Expecter) Subscribe(senderAddress interface{}, destinationAddress interface{}, serverFeatureType interface{}) *SenderInterface_Subscribe_Call {
	return &SenderInterface_Subscribe_Call{Call: _e.mock.On("Subscribe", senderAddress, destinationAddress, serverFeatureType)}
}

func (_c *SenderInterface_Subscribe_Call) Run(run func(senderAddress *model.FeatureAddressType, destinationAddress *model.FeatureAddressType, serverFeatureType model.FeatureTypeType)) *SenderInterface_Subscribe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*model.FeatureAddressType), args[1].(*model.FeatureAddressType), args[2].(model.FeatureTypeType))
	})
	return _c
}

func (_c *SenderInterface_Subscribe_Call) Return(_a0 *model.MsgCounterType, _a1 error) *SenderInterface_Subscribe_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *SenderInterface_Subscribe_Call) RunAndReturn(run func(*model.FeatureAddressType, *model.FeatureAddressType, model.FeatureTypeType) (*model.MsgCounterType, error)) *SenderInterface_Subscribe_Call {
	_c.Call.Return(run)
	return _c
}

// Unbind provides a mock function with given fields: senderAddress, destinationAddress
func (_m *SenderInterface) Unbind(senderAddress *model.FeatureAddressType, destinationAddress *model.FeatureAddressType) (*model.MsgCounterType, error) {
	ret := _m.Called(senderAddress, destinationAddress)

	if len(ret) == 0 {
		panic("no return value specified for Unbind")
	}

	var r0 *model.MsgCounterType
	var r1 error
	if rf, ok := ret.Get(0).(func(*model.FeatureAddressType, *model.FeatureAddressType) (*model.MsgCounterType, error)); ok {
		return rf(senderAddress, destinationAddress)
	}
	if rf, ok := ret.Get(0).(func(*model.FeatureAddressType, *model.FeatureAddressType) *model.MsgCounterType); ok {
		r0 = rf(senderAddress, destinationAddress)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.MsgCounterType)
		}
	}

	if rf, ok := ret.Get(1).(func(*model.FeatureAddressType, *model.FeatureAddressType) error); ok {
		r1 = rf(senderAddress, destinationAddress)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SenderInterface_Unbind_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Unbind'
type SenderInterface_Unbind_Call struct {
	*mock.Call
}

// Unbind is a helper method to define mock.On call
//   - senderAddress *model.FeatureAddressType
//   - destinationAddress *model.FeatureAddressType
func (_e *SenderInterface_Expecter) Unbind(senderAddress interface{}, destinationAddress interface{}) *SenderInterface_Unbind_Call {
	return &SenderInterface_Unbind_Call{Call: _e.mock.On("Unbind", senderAddress, destinationAddress)}
}

func (_c *SenderInterface_Unbind_Call) Run(run func(senderAddress *model.FeatureAddressType, destinationAddress *model.FeatureAddressType)) *SenderInterface_Unbind_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*model.FeatureAddressType), args[1].(*model.FeatureAddressType))
	})
	return _c
}

func (_c *SenderInterface_Unbind_Call) Return(_a0 *model.MsgCounterType, _a1 error) *SenderInterface_Unbind_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *SenderInterface_Unbind_Call) RunAndReturn(run func(*model.FeatureAddressType, *model.FeatureAddressType) (*model.MsgCounterType, error)) *SenderInterface_Unbind_Call {
	_c.Call.Return(run)
	return _c
}

// Unsubscribe provides a mock function with given fields: senderAddress, destinationAddress
func (_m *SenderInterface) Unsubscribe(senderAddress *model.FeatureAddressType, destinationAddress *model.FeatureAddressType) (*model.MsgCounterType, error) {
	ret := _m.Called(senderAddress, destinationAddress)

	if len(ret) == 0 {
		panic("no return value specified for Unsubscribe")
	}

	var r0 *model.MsgCounterType
	var r1 error
	if rf, ok := ret.Get(0).(func(*model.FeatureAddressType, *model.FeatureAddressType) (*model.MsgCounterType, error)); ok {
		return rf(senderAddress, destinationAddress)
	}
	if rf, ok := ret.Get(0).(func(*model.FeatureAddressType, *model.FeatureAddressType) *model.MsgCounterType); ok {
		r0 = rf(senderAddress, destinationAddress)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.MsgCounterType)
		}
	}

	if rf, ok := ret.Get(1).(func(*model.FeatureAddressType, *model.FeatureAddressType) error); ok {
		r1 = rf(senderAddress, destinationAddress)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SenderInterface_Unsubscribe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Unsubscribe'
type SenderInterface_Unsubscribe_Call struct {
	*mock.Call
}

// Unsubscribe is a helper method to define mock.On call
//   - senderAddress *model.FeatureAddressType
//   - destinationAddress *model.FeatureAddressType
func (_e *SenderInterface_Expecter) Unsubscribe(senderAddress interface{}, destinationAddress interface{}) *SenderInterface_Unsubscribe_Call {
	return &SenderInterface_Unsubscribe_Call{Call: _e.mock.On("Unsubscribe", senderAddress, destinationAddress)}
}

func (_c *SenderInterface_Unsubscribe_Call) Run(run func(senderAddress *model.FeatureAddressType, destinationAddress *model.FeatureAddressType)) *SenderInterface_Unsubscribe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*model.FeatureAddressType), args[1].(*model.FeatureAddressType))
	})
	return _c
}

func (_c *SenderInterface_Unsubscribe_Call) Return(_a0 *model.MsgCounterType, _a1 error) *SenderInterface_Unsubscribe_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *SenderInterface_Unsubscribe_Call) RunAndReturn(run func(*model.FeatureAddressType, *model.FeatureAddressType) (*model.MsgCounterType, error)) *SenderInterface_Unsubscribe_Call {
	_c.Call.Return(run)
	return _c
}

// Write provides a mock function with given fields: senderAddress, destinationAddress, cmd
func (_m *SenderInterface) Write(senderAddress *model.FeatureAddressType, destinationAddress *model.FeatureAddressType, cmd model.CmdType) (*model.MsgCounterType, error) {
	ret := _m.Called(senderAddress, destinationAddress, cmd)

	if len(ret) == 0 {
		panic("no return value specified for Write")
	}

	var r0 *model.MsgCounterType
	var r1 error
	if rf, ok := ret.Get(0).(func(*model.FeatureAddressType, *model.FeatureAddressType, model.CmdType) (*model.MsgCounterType, error)); ok {
		return rf(senderAddress, destinationAddress, cmd)
	}
	if rf, ok := ret.Get(0).(func(*model.FeatureAddressType, *model.FeatureAddressType, model.CmdType) *model.MsgCounterType); ok {
		r0 = rf(senderAddress, destinationAddress, cmd)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.MsgCounterType)
		}
	}

	if rf, ok := ret.Get(1).(func(*model.FeatureAddressType, *model.FeatureAddressType, model.CmdType) error); ok {
		r1 = rf(senderAddress, destinationAddress, cmd)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SenderInterface_Write_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Write'
type SenderInterface_Write_Call struct {
	*mock.Call
}

// Write is a helper method to define mock.On call
//   - senderAddress *model.FeatureAddressType
//   - destinationAddress *model.FeatureAddressType
//   - cmd model.CmdType
func (_e *SenderInterface_Expecter) Write(senderAddress interface{}, destinationAddress interface{}, cmd interface{}) *SenderInterface_Write_Call {
	return &SenderInterface_Write_Call{Call: _e.mock.On("Write", senderAddress, destinationAddress, cmd)}
}

func (_c *SenderInterface_Write_Call) Run(run func(senderAddress *model.FeatureAddressType, destinationAddress *model.FeatureAddressType, cmd model.CmdType)) *SenderInterface_Write_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*model.FeatureAddressType), args[1].(*model.FeatureAddressType), args[2].(model.CmdType))
	})
	return _c
}

func (_c *SenderInterface_Write_Call) Return(_a0 *model.MsgCounterType, _a1 error) *SenderInterface_Write_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *SenderInterface_Write_Call) RunAndReturn(run func(*model.FeatureAddressType, *model.FeatureAddressType, model.CmdType) (*model.MsgCounterType, error)) *SenderInterface_Write_Call {
	_c.Call.Return(run)
	return _c
}

// NewSenderInterface creates a new instance of SenderInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewSenderInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *SenderInterface {
	mock := &SenderInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
